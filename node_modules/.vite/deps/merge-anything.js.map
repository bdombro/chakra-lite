{
  "version": 3,
  "sources": ["../../../../../node_modules/merge-anything/dist/index.es.js"],
  "sourcesContent": ["import { isArray, isPlainObject, isSymbol } from 'is-what';\n\nfunction concatArrays(originVal, newVal) {\r\n    if (isArray(originVal) && isArray(newVal)) {\r\n        // concat logic\r\n        return originVal.concat(newVal);\r\n    }\r\n    return newVal; // always return newVal as fallback!!\r\n}\n\nfunction assignProp(carry, key, newVal, originalObject) {\r\n    const propType = {}.propertyIsEnumerable.call(originalObject, key)\r\n        ? 'enumerable'\r\n        : 'nonenumerable';\r\n    if (propType === 'enumerable')\r\n        carry[key] = newVal;\r\n    if (propType === 'nonenumerable') {\r\n        Object.defineProperty(carry, key, {\r\n            value: newVal,\r\n            enumerable: false,\r\n            writable: true,\r\n            configurable: true,\r\n        });\r\n    }\r\n}\r\nfunction mergeRecursively(origin, newComer, compareFn) {\r\n    // always return newComer if its not an object\r\n    if (!isPlainObject(newComer))\r\n        return newComer;\r\n    // define newObject to merge all values upon\r\n    let newObject = {};\r\n    if (isPlainObject(origin)) {\r\n        const props = Object.getOwnPropertyNames(origin);\r\n        const symbols = Object.getOwnPropertySymbols(origin);\r\n        newObject = [...props, ...symbols].reduce((carry, key) => {\r\n            const targetVal = origin[key];\r\n            if ((!isSymbol(key) && !Object.getOwnPropertyNames(newComer).includes(key)) ||\r\n                (isSymbol(key) && !Object.getOwnPropertySymbols(newComer).includes(key))) {\r\n                assignProp(carry, key, targetVal, origin);\r\n            }\r\n            return carry;\r\n        }, {});\r\n    }\r\n    // newObject has all properties that newComer hasn't\r\n    const props = Object.getOwnPropertyNames(newComer);\r\n    const symbols = Object.getOwnPropertySymbols(newComer);\r\n    const result = [...props, ...symbols].reduce((carry, key) => {\r\n        // re-define the origin and newComer as targetVal and newVal\r\n        let newVal = newComer[key];\r\n        const targetVal = isPlainObject(origin) ? origin[key] : undefined;\r\n        // When newVal is an object do the merge recursively\r\n        if (targetVal !== undefined && isPlainObject(newVal)) {\r\n            newVal = mergeRecursively(targetVal, newVal, compareFn);\r\n        }\r\n        const propToAssign = compareFn ? compareFn(targetVal, newVal, key) : newVal;\r\n        assignProp(carry, key, propToAssign, newComer);\r\n        return carry;\r\n    }, newObject);\r\n    return result;\r\n}\r\n/**\r\n * Merge anything recursively.\r\n * Objects get merged, special objects (classes etc.) are re-assigned \"as is\".\r\n * Basic types overwrite objects or other basic types.\r\n */\r\nfunction merge(object, ...otherObjects) {\r\n    return otherObjects.reduce((result, newComer) => {\r\n        return mergeRecursively(result, newComer);\r\n    }, object);\r\n}\r\nfunction mergeAndCompare(compareFn, object, ...otherObjects) {\r\n    return otherObjects.reduce((result, newComer) => {\r\n        return mergeRecursively(result, newComer, compareFn);\r\n    }, object);\r\n}\r\nfunction mergeAndConcat(object, ...otherObjects) {\r\n    return otherObjects.reduce((result, newComer) => {\r\n        return mergeRecursively(result, newComer, concatArrays);\r\n    }, object);\r\n}\r\n// import { Timestamp } from '../test/Timestamp'\r\n// type T1 = { date: Timestamp }\r\n// type T2 = [{ b: string[] }, { b: number[] }, { date: Timestamp }]\r\n// type TestT = Merge<T1, T2>\r\n// type A1 = { arr: string[] }\r\n// type A2 = { arr: number[] }\r\n// type A3 = { arr: boolean[] }\r\n// type TestA = Merge<A1, [A2, A3]>\r\n// interface I1 {\r\n//   date: Timestamp\r\n// }\r\n// interface I2 {\r\n//   date: Timestamp\r\n// }\r\n// const _a: I2 = { date: '' } as unknown as I2\r\n// type TestI = Merge<I1, [I2]>\r\n// // ReturnType<(typeof merge)<I1, I2>>\r\n// const a = merge(_a, [_a])\r\n// interface Arguments extends Record<string | number | symbol, unknown> {\r\n//     key: string;\r\n// }\r\n// const aa1: Arguments = { key: \"value1\" }\r\n// const aa2: Arguments = { key: \"value2\" }\r\n// const aa = merge(a1, a2);\r\n// interface Barguments {\r\n//   key: string\r\n// }\r\n// const ba1: Barguments = { key: 'value1' }\r\n// const ba2: Barguments = { key: 'value2' }\r\n// const ba = merge(ba1, ba2)\r\n// interface Carguments {\r\n//   key: string\r\n// }\r\n// const ca = merge<Carguments, Carguments[]>({ key: 'value1' }, { key: 'value2' })\r\n// type P = Pop<Carguments[]>\n\nexport { concatArrays, merge, mergeAndCompare, mergeAndConcat };\n"],
  "mappings": ";;;;;;;;AAEA,SAAS,aAAa,WAAW,QAAQ;AACrC,MAAI,QAAQ,SAAS,KAAK,QAAQ,MAAM,GAAG;AAEvC,WAAO,UAAU,OAAO,MAAM;AAAA,EAClC;AACA,SAAO;AACX;AAEA,SAAS,WAAW,OAAO,KAAK,QAAQ,gBAAgB;AACpD,QAAM,WAAW,CAAC,EAAE,qBAAqB,KAAK,gBAAgB,GAAG,IAC3D,eACA;AACN,MAAI,aAAa;AACb,UAAM,GAAG,IAAI;AACjB,MAAI,aAAa,iBAAiB;AAC9B,WAAO,eAAe,OAAO,KAAK;AAAA,MAC9B,OAAO;AAAA,MACP,YAAY;AAAA,MACZ,UAAU;AAAA,MACV,cAAc;AAAA,IAClB,CAAC;AAAA,EACL;AACJ;AACA,SAAS,iBAAiB,QAAQ,UAAU,WAAW;AAEnD,MAAI,CAAC,cAAc,QAAQ;AACvB,WAAO;AAEX,MAAI,YAAY,CAAC;AACjB,MAAI,cAAc,MAAM,GAAG;AACvB,UAAMA,SAAQ,OAAO,oBAAoB,MAAM;AAC/C,UAAMC,WAAU,OAAO,sBAAsB,MAAM;AACnD,gBAAY,CAAC,GAAGD,QAAO,GAAGC,QAAO,EAAE,OAAO,CAAC,OAAO,QAAQ;AACtD,YAAM,YAAY,OAAO,GAAG;AAC5B,UAAK,CAAC,SAAS,GAAG,KAAK,CAAC,OAAO,oBAAoB,QAAQ,EAAE,SAAS,GAAG,KACpE,SAAS,GAAG,KAAK,CAAC,OAAO,sBAAsB,QAAQ,EAAE,SAAS,GAAG,GAAI;AAC1E,mBAAW,OAAO,KAAK,WAAW,MAAM;AAAA,MAC5C;AACA,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAAA,EACT;AAEA,QAAM,QAAQ,OAAO,oBAAoB,QAAQ;AACjD,QAAM,UAAU,OAAO,sBAAsB,QAAQ;AACrD,QAAM,SAAS,CAAC,GAAG,OAAO,GAAG,OAAO,EAAE,OAAO,CAAC,OAAO,QAAQ;AAEzD,QAAI,SAAS,SAAS,GAAG;AACzB,UAAM,YAAY,cAAc,MAAM,IAAI,OAAO,GAAG,IAAI;AAExD,QAAI,cAAc,UAAa,cAAc,MAAM,GAAG;AAClD,eAAS,iBAAiB,WAAW,QAAQ,SAAS;AAAA,IAC1D;AACA,UAAM,eAAe,YAAY,UAAU,WAAW,QAAQ,GAAG,IAAI;AACrE,eAAW,OAAO,KAAK,cAAc,QAAQ;AAC7C,WAAO;AAAA,EACX,GAAG,SAAS;AACZ,SAAO;AACX;AAMA,SAAS,MAAM,WAAW,cAAc;AACpC,SAAO,aAAa,OAAO,CAAC,QAAQ,aAAa;AAC7C,WAAO,iBAAiB,QAAQ,QAAQ;AAAA,EAC5C,GAAG,MAAM;AACb;AACA,SAAS,gBAAgB,WAAW,WAAW,cAAc;AACzD,SAAO,aAAa,OAAO,CAAC,QAAQ,aAAa;AAC7C,WAAO,iBAAiB,QAAQ,UAAU,SAAS;AAAA,EACvD,GAAG,MAAM;AACb;AACA,SAAS,eAAe,WAAW,cAAc;AAC7C,SAAO,aAAa,OAAO,CAAC,QAAQ,aAAa;AAC7C,WAAO,iBAAiB,QAAQ,UAAU,YAAY;AAAA,EAC1D,GAAG,MAAM;AACb;",
  "names": ["props", "symbols"]
}
